# 工程实践
这篇博客会记录一些工作中遇到的一些最佳实践。这些实践往往是比较零散的，因此课本上也不会教授的知识，需要在工程中思考获得，甚至是在一次次的事故中习得。

## 平滑上线
### 场景 1

T 组件依赖 P 组件，有个功能需要同时开发 T、P 两个组件，那么**如何开发、如何上线才能保证线上服务不会中断**呢？这需要在文档设计的时候就需要考虑到。

举个例子

T 组件的某个服务会向 P 组件发送一个请求，原接口是 
```
GET /TEST
{
    "user_name": "john"
}
```
现在请求体中需要新增一个字段，但是接口没有变动
```
GET /TEST
{
    "user_name": "john",
    "user_location": "shanghai"
}
```
此时的做法是，

1. 在 P 组件处理 `/TEST` 请求的函数中，处理 `"user_location"` 字段的逻辑需要 `try/catch`, 以应对 T 组件 **切流（切换流量）** 过程中可能存在两种请求的情况。
2. P 组件需要先升级，保证其有处理新的请求体的能力，然后再升级 T 组件。

或者另外一种做法：

1. P 组件中新增一个 http 请求接口 `/TEST1`，用于处理带有新字段的请求。
2. 在 T 组件中新增代理逻辑，根据请求体是否有新增字段来判定走 `/TEST` 还是 `/TEST1` 
3. 升级时，先升级 P 组件

## 依赖冲突

### maven
用户开发的程序中依赖了 spark 和 guava，而 spark 也依赖了 guava，那么用户引用的 guava 中的类有可能来自 spark，此时就导致了依赖冲突。

解决的方法是，**shade 技术**:
在 spark 中将 guava 的 dependency 进行 shade，重新打包，用户程序依赖这个 spark 包。 
当用户再次引用 guava 中的类时，如果该类来自 spark 中，那么 `import` 语句中会带有 spark 的 package 前缀，如 `org.apache.spark.xxx`；
用户可以选择不 import 这个类，而是 import 自己依赖的 guava 中的类，这样的类的 import 就没有 spark 包的前缀。