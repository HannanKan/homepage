# 架构整洁之道
## 前言
// todo
### 左耳朵耗子 R.I.P
程序员可以分为三个层次：普通程序员、工程师、架构师。

* 普通程序员：编写代码，让程序跑起来的人。
* 工程师：考虑易读性、易扩展性、易维护性、性能优化等。
* 架构师：解决问题时，结合**现有经验**、考虑不同的**业界解决方案**，结合**实际场景**做出决策/tradeoff。比如基于业务场景给出解决方案、基于更高级的技术给出解决方案、设计更加灵活的系统等等。比 工程师 站在更高的视角考虑问题。

《代码整洁之道》教你写出易读、可扩展、可维护、可重用的代码，《代码整洁之道：程序员的职业素养》教你怎样变成一个有修养的程序员，而《架构整洁之道》基本上是在描述软件设计的一些理论知识。

《架构整洁之道》大体分成三个部分：编程范式（结构化编程、面向对象编程和函数式编程），设计原则（主要是SOLID），以及软件架构（其中讲了很多高屋建翎的内容）

架构或者设计，核心要解决的问题是：分离 控制与逻辑。

* 逻辑：指代业务逻辑，解决用户的问题
* 控制：与业务无关的部分，比如多线程、异步、服务发现、部署、弹性伸缩等**切面**。

### yurii-says/余晟
架构设计是一门复杂的学问，要综合考虑各种因素，**做出权衡**：

* **编码**
* **质量**
* **部署**
* **发布**
* **运维**
* **排障**
* **升级**
* 等等

## 概述
为什么要考虑软件的**架构与设计**？好的架构能够有如下优势

* 节省项目构建、维护的人力成本
* 让需求易于实现，只需对项目做很小的变更
* 避免缺陷

也即，用最小的成本，最大程度满足功能性和灵活性的需求。


### 第一章、设计与架构究竟是什么

架构是从**更高、更抽象的视角**描述软件、设计是从更**底层的视角**描述软件，二者不可分割。后文中出现的架构包括了架构与设计两层意思。

软件架构的**终极目标**是，用**最小的人力成本**来满足**构建**和**维护**该系统的需求。

### 第二章、两个价值的维度
软件系统的两个价值维度：

* **系统行为**的正确性：当前系统能否按照预期运行。
* **系统架构**的灵活性：需求迭代时，系统更新的难易程度。

两者都很重要，但前者**更加紧急**，因为系统在每时每刻都要保证行为的正确性；后者虽然不紧急，但很**容易被忽略**，而忽略的后果很严重，忽略后系统将变得越来越难以维护，终有一天变得无法再修改，只能重构来实现新功能需求。

系统行为的正确性不需要更多强调，但是系统架构的灵活性则更需要牢记，在设计系统之初、在系统演进时都要思考。

## 从基础构建开始：编程范式
编程范式指的是程序采用什么样的代码结构，与具体的编程语言关系相对较小。

### 第三章、编程范式总览

三类编程范式及其意义：

* 结构化编程：对程序控制权的直接转移进行了限制和规范，通俗讲就是限制了`goto`语句
* 面向对象编程（OOP）：对程序控制权的间接转移进行了限制和规范, 通俗讲就是限制了函数指针，程序就是类及其之间的函数调用
* 函数式编程：对程序中的赋值进行了限制和规范，通俗讲就是限制了赋值语句

与架构三大关注点的关系：
  
* 功能性：多态可以跨越架构边界，对应 OOP
* 组件独立性：各个模块/函数内部实现则遵循结构化编程范式
* 数据管理：数据存放与访问权限，对应函数式编程

每个范式都约束了某种编写代码的方式，明确了**什么不应该做**。

### 第四章、结构化编程
`goto` 语句导致功能/模块无法被递归拆分成更小的部分，所以需要限制。

强调将大型系统**按照功能拆分**成各个模块和组件。并且每个模块/组件**可以被方便的测试**（单元测试 or 集成测试）。


### 第五章、面向对象编程
**封装**：数据和操作数据的函数封装在一个类中，要求高内聚、低耦合。

**继承**：可以在某个作用域内对外部定义的某一组变量与函数进行覆盖。

**多态**，实质是一种函数指针的应用：

* 例如，在C++中，类中的虚函数地址都被记录在 vtable 的数据结构中。对虚函数的每次调用都要先查询这个表；接口的实现类的构造函数负责将该类的虚函数地址加载到对象的 vtable 中。

如果没有面向对象技术，直接使用函数指针实现多态充满了危险，因为对**指针的正确调用**需要人为遵守约定，否则会有 bug 或出错。因此，面向对象编程语言为我们消除了人工遵守约定的必要，也就等于消除了这方面的危险性。采用面向对象编程语言让多态实现变得非常简单，让一个传统C程序员可以去做以前不敢想的事情。

通过多态，面向对象编程其实是对程序间接控制权的转移进行了约束。

通过多态，能够实现**插件式架构**，可以在调用方不做变更情况下，替换底层的实现。

* 例如，Unix 系统将 IO 设备设计成插件形式，即不同的驱动设备程序只要**实现指定的接口**，就能被系统调用。

**依赖反转**，是一种设计思想，这里可以粗暴的理解为**面向接口编程**。上层函数只能调用底层的类的接口，而接口一般都是稳定不变的，但是接口的实现可以有很多变化。

* 在不用**依赖反转**时，依赖的方向是 上层函数依赖其调用的函数。
* 在使用**依赖反转**时，依赖的方向变成，底层函数的实现需要依赖事先约定好的接口，具体来说就是函数签名不能变。


依赖反转的好处是

* 让组件具有独立部署能力：当某个组件的源代码需要修改时，仅仅需要重新部署该组件，不需要更改其他组件
* 让系统具有独立开发能力：如果系统中的所有组件都可以独立部署，那它们就可以由不同的团队并行开发，这就是所谓的独立开发能力

举个例子：利用**依赖反转**的设计，让数据库模块和用户界面模块都依赖于业务逻辑模块（而非相反），让用户界面和数据库都成为业务逻辑的插件。这样一来，业务逻辑、用户界面以及数据库就可以被编译成三个独立的组件或者部署单元。

***面向对象编程对架构的意义***：面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可以被编译成插件，实现独立于高层组件的开发和部署。

### 第六章、函数式编程
函数式编程中一个核心的概念是 —— 不可变性。比如 Scala 编程语言中的 `val` 关键字指定不可变变量。

不可变性与架构的关系：所有的竞争问题、死锁问题、并发更新问题都是由可变变量导致的。

根据可变性，对系统进行隔离：

* 一个架构设计良好的应用程序应该将状态修改的部分和不需要修改状态的部分隔离成单独的组件，然后用合适的机制来保护可变量。
* 软件架构师应该着力于将大部分处理逻辑都归于不可变组件中，可变状态组件的逻辑应该越少越好。

不可变性在架构上的应用 —— [事件溯源](https://juejin.cn/post/7122768490863263781)。举个例子

* 银行维护账户余额时，不保存具体账户余额，仅仅保存事务日志，那么当有人想查询账户余额时，我们就将全部交易记录取出，并且每次都得从最开始到当下进行累计。这样就不需要变量了。类似日志重放。
* 并不需要这个设计永远可行，而且可能在整个程序的生命周期内，我们有足够的存储和处理能力来满足它。

## 设计原则
这一部分内容主要讲如何利用 SOLID 原则将数据和函数组织成类，以及将这些类链接成程序。这里的程序可以指大型软件系统，也可以指单个组件。
下面简单、直观的介绍 SOLID 原则。

* SRP: 单一职责原则
  * 每个软件模块都有且只有一个被改变的理由。
* OCP: 开闭原则
  * 如果软件系统想要更容易被改变，那么其设计就必须允许新增代码来修改系统行为，而非只能靠修改原来的代码。
* LSP: 里氏替换原则
  * 如果想用可替换的组件来构建软件系统，那么这些组件就必须遵守同一个约定，一遍让这些组件可以相互替换。
* ISP: 接口隔离原则
  * 软件设计避免不必要的依赖
* DIP: 依赖反转原则
  * 高层策略性代码不应该依赖底层实现细节的代码，恰恰相反，那些实现底层细节的代码应该依赖高层策略性的代码。


### 第七章、SRP 单一职责原则
每一个软件模块都应该只对**一类行为者**负责。

文章举了一个非常有意思的例子，一个 `Employee` 类里面提供了 `calculatePay()` 和 `reportHours()` 两个函数，前者是为了给财务部门计算薪酬、后者是为了给人力部门汇报工时。

![picture 2](../image/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/IMG_20230923-185344494.png)  

由于在一个类里面，所以这两个函数复用了 `regularHours()` 函数来计算工时。

![picture 6](../image/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/IMG_20230923-190810921.png)


如果财务部门需要修改工时计算方法，而负责修改的程序员由于没有注意到 `regularHours()` 函数还被 `reportHours()` 调用了，所以直接修改了 `regularHours()` 函数。此时人力部门看到结果也是经过修改过后的数据！！很容易导致问题！！

因此，需要将 `calculatePay()` 和 `reportHours()`  两个功能实现拆分到不同的类当中去，并使用各自私有的计算工时的函数。这样，有两个类分别对应财务和人力的计算逻辑，它们只对**一个行为者**负责。

### 第八章、OCP 开闭原则

设计良好的计算机软件应该易于扩展，同时抗拒修改。换句话说，一个设计良好的计算机系统应该在不需要修改的前提下就可以轻易被扩展。

通俗的说，设计要考虑软件的**扩展性**。

实现的方式（个人理解）就是，利用**依赖反转**原则，将高层抽象定义成接口，应用程序面向接口编程，而屏蔽底层实现细节，同时接口也可以实现多态。接口尽量保证稳定。

### 第九章、LSP 里氏替换原则

面向接口编程，应用程序通过调用各个接口完成处理逻辑，实现接口的不同衍生类可以相互替换。

### 第十章、ISP 接口隔离原则

任何层次的设计，都不应该依赖它并不需要的东西。

举个例子，有如下的 OPS 类有三个函数，分别被 User1、User2、User3 类中的函数直接调用。这种直接依赖导致任何对 OPS 的 op1 函数的修改也会导致 User2、User3 被重新编译。

```java
public class OPS {
  public void op1() {}
  public void op2() {}
  public void op3() {}
} 
```

在 User 和 OPS 中间添加一个接口层，让底层实现 OPS 依赖接口（依赖反转），User 类调用接口。这样就能保证每个类不依赖最小化。

```java
public interface U1Ops {public void op1();}
public interface U2Ops {public void op2();}
public interface U3Ops {public void op3();}

public class OPS implements U1Ops, U2Ops, U3Ops {
  @Override
  public void op1() {}
  @Override
  public void op2() {}
  @Override
  public void op3() {}
} 
```

### 第十一章、DIP 依赖反转原则
依赖反转原则(DIP)主要想告诉我们的是，如果想要设计一个灵活的系统，在源代码层次的依赖关系中就应该多引用抽象类型，而非具体实现。

也就是说，在Java这类静态类型的编程语言中，在使用use、import、include这些语句时应该只引用那些包含接口、抽象类或者其他抽象类型声明的源文件，不应该引用任何具体实现。这里是针对那些经常会变动的实现而言的，并不包括像 String 这类稳定实现的类。

通过依赖稳定的抽象层，来实现依赖反转。有一些可以**按需**遵循的最佳实践

* 应在代码中多使用抽象接口，尽量避免使用那些多变的具体实现类
* 不要在具体实现类上创建衍生类
* 不要覆盖(override)包含具体实现的函数

以下图为例，这条曲线将整个系统划分为两部分组件：抽象接口与其具体实现。抽象接口组件中包含了应用的所有高阶业务规则，而具体实现组件中则包括了所有这些业务规则所需要做的具体操作及其相关的细节信息。图中曲线代表**架构边界**。

![picture 10](../image/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/IMG_20230924-011627203.png)  
