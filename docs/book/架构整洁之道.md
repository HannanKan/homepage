# 架构整洁之道
## 前言
// todo
### 左耳朵耗子 R.I.P
程序员可以分为三个层次：普通程序员、工程师、架构师。

* 普通程序员：编写代码，让程序跑起来的人。
* 工程师：考虑易读性、易扩展性、易维护性、性能优化等。
* 架构师：解决问题时，结合**现有经验**、考虑不同的**业界解决方案**，结合**实际场景**做出决策/tradeoff。比如基于业务场景给出解决方案、基于更高级的技术给出解决方案、设计更加灵活的系统等等。比 工程师 站在更高的视角考虑问题。

《代码整洁之道》教你写出易读、可扩展、可维护、可重用的代码，《代码整洁之道：程序员的职业素养》教你怎样变成一个有修养的程序员，而《架构整洁之道》基本上是在描述软件设计的一些理论知识。

《架构整洁之道》大体分成三个部分：编程范式（结构化编程、面向对象编程和函数式编程），设计原则（主要是SOLID），以及软件架构（其中讲了很多高屋建翎的内容）

架构或者设计，核心要解决的问题是：分离 控制与逻辑。

* 逻辑：指代业务逻辑，解决用户的问题
* 控制：与业务无关的部分，比如多线程、异步、服务发现、部署、弹性伸缩等**切面**。

### yurii-says/余晟
架构设计是一门复杂的学问，要综合考虑各种因素，**做出权衡**：

* **编码**
* **质量**
* **部署**
* **发布**
* **运维**
* **排障**
* **升级**
* 等等

## 概述
为什么要考虑软件的**架构与设计**？好的架构能够有如下优势

* 节省项目构建、维护的人力成本
* 让需求易于实现，只需对项目做很小的变更
* 避免缺陷

也即，用最小的成本，最大程度满足功能性和灵活性的需求。


### 第一章、设计与架构究竟是什么

架构是从**更高、更抽象的视角**描述软件、设计是从更**底层的视角**描述软件，二者不可分割。后文中出现的架构包括了架构与设计两层意思。

软件架构的**终极目标**是，用**最小的人力成本**来满足**构建**和**维护**该系统的需求。

### 第二章、两个价值的维度
软件系统的两个价值维度：

* **系统行为**的正确性：当前系统能否按照预期运行。
* **系统架构**的灵活性：需求迭代时，系统更新的难易程度。

两者都很重要，但前者**更加紧急**，因为系统在每时每刻都要保证行为的正确性；后者虽然不紧急，但很**容易被忽略**，而忽略的后果很严重，忽略后系统将变得越来越难以维护，终有一天变得无法再修改，只能重构来实现新功能需求。

系统行为的正确性不需要更多强调，但是系统架构的灵活性则更需要牢记，在设计系统之初、在系统演进时都要思考。

## 从基础构建开始：编程范式
编程范式指的是程序采用什么样的代码结构，与具体的编程语言关系相对较小。

### 第三章、编程范式总览

三类编程范式及其意义：

* 结构化编程：对程序控制权的直接转移进行了限制和规范，通俗讲就是限制了`goto`语句
* 面向对象编程（OOP）：对程序控制权的间接转移进行了限制和规范, 通俗讲就是限制了函数指针，程序就是类及其之间的函数调用
* 函数式编程：对程序中的赋值进行了限制和规范，通俗讲就是限制了赋值语句

与架构三大关注点的关系：
  
* 功能性：多态可以跨越架构边界，对应 OOP
* 组件独立性：各个模块/函数内部实现则遵循结构化编程范式
* 数据管理：数据存放与访问权限，对应函数式编程

每个范式都约束了某种编写代码的方式，明确了**什么不应该做**。

### 第四章、结构化编程
`goto` 语句导致功能/模块无法被递归拆分成更小的部分，所以需要限制。

强调将大型系统**按照功能拆分**成各个模块和组件。并且每个模块/组件**可以被方便的测试**（单元测试 or 集成测试）。


### 第五章、面向对象编程
**封装**：数据和操作数据的函数封装在一个类中，要求高内聚、低耦合。

**继承**：可以在某个作用域内对外部定义的某一组变量与函数进行覆盖。

**多态**，实质是一种函数指针的应用：

* 例如，在C++中，类中的虚函数地址都被记录在 vtable 的数据结构中。对虚函数的每次调用都要先查询这个表；接口的实现类的构造函数负责将该类的虚函数地址加载到对象的 vtable 中。

如果没有面向对象技术，直接使用函数指针实现多态充满了危险，因为对**指针的正确调用**需要人为遵守约定，否则会有 bug 或出错。因此，面向对象编程语言为我们消除了人工遵守约定的必要，也就等于消除了这方面的危险性。采用面向对象编程语言让多态实现变得非常简单，让一个传统C程序员可以去做以前不敢想的事情。

通过多态，面向对象编程其实是对程序间接控制权的转移进行了约束。

通过多态，能够实现**插件式架构**，可以在调用方不做变更情况下，替换底层的实现。

* 例如，Unix 系统将 IO 设备设计成插件形式，即不同的驱动设备程序只要**实现指定的接口**，就能被系统调用。

**依赖反转**，是一种设计思想，这里可以粗暴的理解为**面向接口编程**。上层函数只能调用底层的类的接口，而接口一般都是稳定不变的，但是接口的实现可以有很多变化。

* 在不用**依赖反转**时，依赖的方向是 上层函数依赖其调用的函数。
* 在使用**依赖反转**时，依赖的方向变成，底层函数的实现需要依赖事先约定好的接口，具体来说就是函数签名不能变。


依赖反转的好处是

* 让组件具有独立部署能力：当某个组件的源代码需要修改时，仅仅需要重新部署该组件，不需要更改其他组件
* 让系统具有独立开发能力：如果系统中的所有组件都可以独立部署，那它们就可以由不同的团队并行开发，这就是所谓的独立开发能力

举个例子：利用**依赖反转**的设计，让数据库模块和用户界面模块都依赖于业务逻辑模块（而非相反），让用户界面和数据库都成为业务逻辑的插件。这样一来，业务逻辑、用户界面以及数据库就可以被编译成三个独立的组件或者部署单元。

***面向对象编程对架构的意义***：面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可以被编译成插件，实现独立于高层组件的开发和部署。

### 第六章、函数式编程
函数式编程中一个核心的概念是 —— 不可变性。比如 Scala 编程语言中的 `val` 关键字指定不可变变量。

不可变性与架构的关系：所有的竞争问题、死锁问题、并发更新问题都是由可变变量导致的。

根据可变性，对系统进行隔离：

* 一个架构设计良好的应用程序应该将状态修改的部分和不需要修改状态的部分隔离成单独的组件，然后用合适的机制来保护可变量。
* 软件架构师应该着力于将大部分处理逻辑都归于不可变组件中，可变状态组件的逻辑应该越少越好。

不可变性在架构上的应用 —— [事件溯源](https://juejin.cn/post/7122768490863263781)。举个例子

* 银行维护账户余额时，不保存具体账户余额，仅仅保存事务日志，那么当有人想查询账户余额时，我们就将全部交易记录取出，并且每次都得从最开始到当下进行累计。这样就不需要变量了。类似日志重放。
* 并不需要这个设计永远可行，而且可能在整个程序的生命周期内，我们有足够的存储和处理能力来满足它。

## 设计原则

### 第七章、单一职责原则